;; MISBOT Claim Contract
;; Allows users to claim TON rewards with signature verification

#include "imports/stdlib.fc";

;; Storage structure:
;; admin_address - Address that can sign claims
;; claimed_nonces - Dictionary of used nonces to prevent replay attacks

(slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),  ;; admin_address
        ds~load_dict()       ;; claimed_nonces
    );
}

() save_data(slice admin_address, cell claimed_nonces) impure inline {
    set_data(begin_cell()
        .store_slice(admin_address)
        .store_dict(claimed_nonces)
        .end_cell()
    );
}

;; Verify signature
int verify_signature(int hash, slice signature, int public_key) inline_ref {
    return check_signature(hash, signature, public_key);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return (); ;; ignore bounced messages
    }
    
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    
    (slice admin_address, cell claimed_nonces) = load_data();
    
    ;; Claim operation (op = 1)
    if (op == 1) {
        int nonce = in_msg_body~load_uint(64);
        int amount = in_msg_body~load_coins();
        slice signature = in_msg_body~load_bits(512);
        
        ;; Check if nonce already used
        (slice nonce_value, int found) = claimed_nonces.udict_get?(64, nonce);
        throw_if(100, found); ;; Nonce already used
        
        ;; Build message to verify
        cell msg = begin_cell()
            .store_slice(sender_address)
            .store_uint(nonce, 64)
            .store_coins(amount)
            .end_cell();
        
        int hash = cell_hash(msg);
        
        ;; Get admin public key (you'll need to store this)
        int public_key = 0; ;; Replace with actual public key
        
        ;; Verify signature
        throw_unless(101, verify_signature(hash, signature, public_key));
        
        ;; Mark nonce as used
        claimed_nonces~udict_set(64, nonce, begin_cell().store_uint(1, 1).end_cell().begin_parse());
        save_data(admin_address, claimed_nonces);
        
        ;; Send TON to user
        var msg_to_send = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();
        
        send_raw_message(msg_to_send, 1);
        return ();
    }
    
    throw(0xffff);
}

;; Get methods
(slice) get_admin_address() method_id {
    (slice admin_address, cell claimed_nonces) = load_data();
    return admin_address;
}

int is_nonce_used(int nonce) method_id {
    (slice admin_address, cell claimed_nonces) = load_data();
    (slice nonce_value, int found) = claimed_nonces.udict_get?(64, nonce);
    return found;
}
